import { Marked } from "marked";
import { logger } from "./logging.js";
export { init, ctx };
function initProvidable(ictx) {
    return {
        get() {
            return {
                ...ictx(),
            };
        },
    };
}
function completable(ictx) {
    return {
        complete: (rest) => {
            _createCtx({
                ...ictx.get(),
                ...rest,
            });
            return ContextBuilder();
        },
    };
}
function InitialContextBuilder(base) {
    _setInitial(base);
    const provider = initProvidable(_getInitial);
    const completer = completable(provider);
    return Object.assign(provider, completer);
}
// Start building a context object from the given Options & Mode.
//
// Parses options into matching context properties. Returns a function ready to
// complete building the Context object when all properties are available.
function init(opts, mode) {
    let renderFn;
    if (!opts.renderFn) {
        const marked = new Marked();
        renderFn = async (md, _) => {
            return { "main-content": await marked.parse(md) };
        };
    }
    else {
        renderFn = opts.renderFn;
    }
    const ictx = InitialContextBuilder({
        cssFile: opts.cssFile,
        htmlTemplate: opts.htmlTemplate,
        mode: mode ?? "dev",
        renderFn,
    });
    return ictx;
}
if (import.meta.vitest) {
    const { expect, test } = await import("vitest");
    test("init creates a partially complete context", () => {
        logger().dbg("in test");
        expect(1).toEqual(1);
    });
}
// Get an instance of the Context object w/ methods for operating on its data
function ctx() {
    if (!!!_ctx)
        throw new TypeError("Context not yet initialized, wait until configResolved hook has" +
            "completed before attempting to access Context object.");
    return ContextBuilder();
}
function ContextBuilder() {
    const providerOut = outProvidable(_getCtx);
    const provider = ctxProvidable(_getCtx);
    const updater = updatable(_getCtx);
    const devChecker = devCheckable(_getCtx);
    const filterChecks = inExclusionCheckable(_getCtx);
    return Object.assign({ getOut: providerOut.get }, provider, updater, devChecker, filterChecks);
}
function ctxProvidable(ctx) {
    return {
        get() {
            return { ...ctx() };
        },
    };
}
function outProvidable(ctx) {
    return {
        get() {
            return { pages: ctx().pages };
        },
    };
}
function updatable(ctx) {
    return {
        set(values) {
            _updateCtx(values);
            return ctx();
        },
    };
}
function devCheckable(ctx) {
    return {
        isDev() {
            return ctx().mode == "dev";
        },
    };
}
function inExclusionCheckable(ctx) {
    return {
        includes(id) {
            return (Object.keys(ctx().pages).includes(id) ||
                ctx().paths.includes(id));
        },
        excludes(id) {
            return ctx().excluded.includes(id);
        },
    };
}
let _ictx;
function _setInitial(base) {
    _ictx = base;
}
function _getInitial() {
    return _ictx;
}
let _ctx;
function _createCtx(base) {
    _ctx = base;
}
function _updateCtx(base) {
    _ctx = {
        ..._ctx,
        ...base,
    };
}
function _getCtx() {
    return _ctx;
}
//# sourceMappingURL=ctx.js.map