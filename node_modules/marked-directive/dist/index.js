import x from "moo";
var k = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function w(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var b = { exports: {} };
b.exports;
(function(e) {
  (function(t, s, i) {
    function r(a) {
      var n = this, c = p();
      n.next = function() {
        var f = 2091639 * n.s0 + n.c * 23283064365386963e-26;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = f - (n.c = f | 0);
      }, n.c = 1, n.s0 = c(" "), n.s1 = c(" "), n.s2 = c(" "), n.s0 -= c(a), n.s0 < 0 && (n.s0 += 1), n.s1 -= c(a), n.s1 < 0 && (n.s1 += 1), n.s2 -= c(a), n.s2 < 0 && (n.s2 += 1), c = null;
    }
    function l(a, n) {
      return n.c = a.c, n.s0 = a.s0, n.s1 = a.s1, n.s2 = a.s2, n;
    }
    function u(a, n) {
      var c = new r(a), f = n && n.state, o = c.next;
      return o.int32 = function() {
        return c.next() * 4294967296 | 0;
      }, o.double = function() {
        return o() + (o() * 2097152 | 0) * 11102230246251565e-32;
      }, o.quick = o, f && (typeof f == "object" && l(f, c), o.state = function() {
        return l(c, {});
      }), o;
    }
    function p() {
      var a = 4022871197, n = function(c) {
        c = String(c);
        for (var f = 0; f < c.length; f++) {
          a += c.charCodeAt(f);
          var o = 0.02519603282416938 * a;
          a = o >>> 0, o -= a, o *= a, a = o >>> 0, o -= a, a += o * 4294967296;
        }
        return (a >>> 0) * 23283064365386963e-26;
      };
      return n;
    }
    s && s.exports ? s.exports = u : this.alea = u;
  })(
    k,
    e
  );
})(b);
var $ = b.exports;
const _ = /* @__PURE__ */ w($), h = x.compile({
  /**
   * Matches various white space characters, including tab, vertical tab, form
   * feed, zero-width non-breaking space, and Unicode space separators.
   */
  WhiteSpace: { match: /[\t\v\f\ufeff\p{Zs}]+/u, lineBreaks: !0 },
  /**
   * Matches various line break sequences, including carriage return followed by
   * line feed, carriage return, line feed, and Unicode line/paragraph separators.
   */
  Lines: { match: /\r?\n|[\r\u2028\u2029]/u, lineBreaks: !0 },
  /**
   * Matches (literally) identifiers followed by collon (`:`) that may include
   * Unicode characters and escape sequences.
   */
  ObjectKey: /\[?(?:\x23)?(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+\]?(?=:)/u,
  /**
   * Matches various punctuators commonly used in programming languages
   * and regular expressions. It includes operators, delimiters, and special
   * characters.
   */
  Punctuator: /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![/*]))=?|[?~,:;[\](){}]/u,
  /**
   * Matches boolean literals, allowing for optional single or double quotes.
   */
  BooleanLiteral: /true|false/u,
  /**
   * Matches various forms of numeric literals, including hexadecimal, octal,
   * binary, decimal, and scientific notation.
   */
  NumericLiteral: /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/u,
  /**
   * Matches single-quoted and double-quoted string literals, allowing for
   * escaping of quotes and newlines within the string.
   */
  StringLiteral: {
    match: /(?:'(?:(?!')[^\\\n\r]|\\(?:\r\n|[^]))*')|(?:"(?:(?!")[^\\\n\r]|\\(?:\r\n|[^]))*")/u,
    value: (e) => `"${e.slice(1, -1)}"`
  },
  /**
   * Matches identifiers that may include Unicode characters and escape
   * sequences.
   */
  Identifier: /(?:\x23)?(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/u
});
function y(e, t = {}) {
  const s = e.trim().replace(/[,]+$/, "");
  if (s === "") return "{}";
  if (!A(s)) throw new TypeError("Unexpected input format");
  let i = "";
  h.reset(s);
  for (const r of h)
    if (!(r.type === "WhiteSpace" || r.type === "Lines")) {
      switch (r.type) {
        case "Identifier":
          r.value = `"${t[r.value] || r.value}"`;
          break;
        case "ObjectKey":
          r.value.slice(0, 1) === "[" && r.value.slice(-1) === "]" ? r.value = `"${t[r.value.slice(1, -1)] || r.value.slice(1, -1)}"` : r.value = `"${r.value}"`;
          break;
      }
      i += r.value;
    }
  return i.replace(/,([}\]])/g, "$1");
}
function A(e) {
  return e.startsWith("{") && e.endsWith("}") || e.startsWith("[") && e.endsWith("]");
}
const F = /[ \t\v\f\ufeff]+/, S = (
  // eslint-disable-next-line no-control-regex
  /(?:(?![\s\x00\x22\x27\x3E\x2F\x3D\x00-\x1F\x7F-\x9F])[^\s\x00-\x1F\x7F-\x9F\x22\x27\x3E\x2F\x3D])+/
), L = /[.#](?:(?!-?\d)(?:[a-zA-Z0-9\xA0-\uFFFF_-])+)/, E = new RegExp("(?<==)(?:true|false)"), D = new RegExp("(?<==)-?(?:(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|-?0n|-?[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|-?0[0-7]+)"), N = new RegExp(`(?<==)'(?!.*&[0-9a-zA-Z]+;)[^'\\\\]*(?:\\\\.|\\\\n[^"\\\\]*|&[^0-9a-zA-Z;]*)*'`), W = new RegExp('(?<==)"(?!.*&[0-9a-zA-Z]+;)[^"\\\\]*(?:\\\\.|\\\\n[^"\\\\]*|&[^0-9a-zA-Z;]*)*"'), j = new RegExp("(?<==)[^\"\\s'`=<>\\x00]+");
function m(e) {
  const t = typeof e == "string" && /^(['"]).*?\1$/.test(e) ? (
    // omit quotes
    e.slice(1, -1)
  ) : e;
  return t.startsWith("[") && t.endsWith("]") || t.startsWith("{") && t.endsWith("}") ? JSON.parse(y(t)) : t;
}
function z(e) {
  let t = "";
  for (const s in e) {
    const i = e[s];
    switch (typeof i) {
      case "object":
        t += ` ${s}='${JSON.stringify(i)}'`;
        break;
      case "string":
        t += ` ${s}="${i}"`;
        break;
      case "number":
      case "boolean":
        t += ` ${s}=${i}`;
        break;
    }
  }
  return t.slice(1);
}
const v = x.states({
  main: {
    WhiteSpace: F,
    AttributeShorthand: L,
    BooleanLiteral: {
      match: E,
      value(e) {
        return e === "true";
      }
    },
    NumericLiteral: {
      match: D,
      value(e) {
        const t = Number(e);
        return Number.isNaN(t) ? Number(e.replace(/_|n$/g, "")) : Number(e);
      }
    },
    SingleQuotedValue: {
      match: N,
      value: m,
      type: () => "StringLiteral"
    },
    DoubleQuotedLiteral: {
      match: W,
      value: m,
      type: () => "StringLiteral"
    },
    UnquotedLiteral: {
      match: j,
      value: m,
      type: () => "StringLiteral"
    },
    AttributeName: S,
    Separator: "="
  }
});
function C(e) {
  let t = null;
  const s = v.reset(e), i = {};
  Object.defineProperties(i, {
    toString: {
      writable: !1,
      enumerable: !1,
      configurable: !1,
      value: () => z(i)
    },
    getTokens: {
      writable: !1,
      enumerable: !1,
      configurable: !1,
      value: () => Array.from(v.reset(e))
    }
  });
  const r = [];
  for (const { type: l, value: u } of s)
    switch (l) {
      case "AttributeName":
        t = u, i[t] = t;
        break;
      case "AttributeShorthand":
        u[0] === "." ? r.push(u.slice(1)) : u[0] === "#" && (i.id = u.slice(1));
        break;
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
        t && (t === "class" && r.push(u), i[t] = u, t = null);
        break;
    }
  return r.length && (i.class = r.join(" ")), i;
}
const O = x.compile({
  spaces: /[\t\v\f\ufeff ]+/,
  name: /[a-zA-Z][\w-]*/,
  attrs: {
    match: /\{.*\}/,
    value: (e) => C(e.slice(1, -1))
  },
  text: {
    match: /\[.*\]/,
    value: (e) => e.slice(1, -1)
  },
  blockText: { match: /[\s\S]+/, lineBreaks: !0 }
});
function T(e) {
  const { type: t, level: s, raw: i, content: r, marker: l, tag: u } = e, p = O.reset(r);
  let a, n, c = "", f = [];
  for (const { type: o, value: d } of p)
    switch (o) {
      case "name":
        a = d;
        break;
      case "attrs":
        n = d;
        break;
      case "text":
      case "blockText":
        c = d, f = s === "container" ? this.lexer.blockTokens(d) : this.lexer.inlineTokens(d);
        break;
    }
  return {
    type: t,
    raw: i,
    meta: { level: s, marker: l, tag: u, name: a },
    attrs: n,
    text: c,
    tokens: f
  };
}
function Z(e, t) {
  switch (e) {
    case "container":
      return `^${t}([\\s\\S]*?)\\n${t}`;
    case "block":
      return `^${t}((?:[a-zA-Z][\\w-]*|[\\{\\[].*?[\\}\\]])+)`;
    case "inline":
      return `^${t}((?:[a-zA-Z][\\w-]*|[\\{].*?[\\}]+|[\\[].*?[\\]])+)`;
  }
}
function B(e) {
  return e[0].toUpperCase() + e.slice(1).toLowerCase();
}
function g(e) {
  return [
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ].includes(e);
}
function R(e) {
  const { meta: t, attrs: s, tokens: i = [] } = e, r = t.name || t.tag;
  let l = `<${r}`;
  return l += s ? " " + s.toString() : "", l += g(r) ? " />" : ">", l += t.level === "container" ? `
` : "", g(r) || (l += t.level === "container" ? this.parser.parse(i) : this.parser.parseInline(i), l += `</${r}>`), l += t.level === "inline" ? "" : `
`, l;
}
const I = [
  { level: "container", marker: ":::" },
  { level: "block", marker: "::" },
  { level: "inline", marker: ":" }
];
function U(e = I) {
  return {
    extensions: e.map(
      ({ level: t, marker: s, tag: i, renderer: r }) => {
        const l = _(s).int32(), u = `directive${B(t)}${l}`;
        return {
          name: u,
          level: t === "inline" ? "inline" : "block",
          start: (p) => {
            var a;
            return (a = p.match(new RegExp(s))) == null ? void 0 : a.index;
          },
          tokenizer(p) {
            const a = Z(t, s), n = p.match(new RegExp(a));
            if (n) {
              const [c, f = ""] = n;
              return T.call(this, {
                type: u,
                level: t,
                raw: c,
                content: f,
                marker: s,
                tag: i || (t === "inline" ? "span" : "div")
              });
            }
          },
          renderer: r || R
        };
      }
    )
  };
}
export {
  U as createDirectives,
  g as isVoidElements,
  I as presetDirectiveConfigs
};
